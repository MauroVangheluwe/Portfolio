---
import { getCollection, render } from "astro:content";
import type { CollectionEntry } from "astro:content";
import BaseLayout from "../../layouts/BaseLayout.astro";

export async function getStaticPaths() {
  const projects: CollectionEntry<"projects">[] =
    await getCollection("projects");
  return projects.map((project) => ({
    params: { slug: project.id },
    props: { project },
  }));
}

const { project } = Astro.props as { project: CollectionEntry<"projects"> };

const { Content } = await render(project);
const {
  name,
  description,
  creativeField,
  duration,
  year,
  client,
  software,
  imgs,
  websiteImgIndexes,
  iframes,
  iframeIndexes,
} = project.data;
---

<BaseLayout title={project.data.name}>
  <main class="project-detail">
    <section class="project-info-grid">
      <div class="info-column">
        <h3 class="info-title">Creative Field</h3>
        <p class="info-content">{creativeField.join(", ")}</p>
      </div>

      <div class="info-column">
        <h3 class="info-title">Duration & Year</h3>
        <p class="info-content">{duration} · {year}</p>
      </div>

      <div class="info-column">
        <h3 class="info-title">Client</h3>
        <p class="info-content">{client}</p>
      </div>

      <div class="info-column">
        <h3 class="info-title">Software</h3>
        <p class="info-content">{software.join(", ")}</p>
      </div>
    </section>

    <h1 class="project-name" id="project-name">{name}</h1>
    <p class="project-description">{description}</p>

    {
      imgs && imgs.length > 0 && (
        <div class="gallery" id="gallery" data-image-count={imgs.length}>
          {imgs.map((imgSrc, index) => {
            const isIframePlaceholder = imgSrc === "IFRAME_PLACEHOLDER";
            const isIframeIndex = iframeIndexes?.includes(index);

            if (isIframePlaceholder || isIframeIndex) {
              const iframeData = iframes?.[iframeIndexes?.indexOf(index) ?? 0];
              if (!iframeData) return null;

              return (
                <iframe
                  src={iframeData.src}
                  width={iframeData.width || 1200}
                  height={iframeData.height || 675}
                  class="gallery-item gallery-iframe"
                  data-is-website="false"
                  allowfullscreen
                  style="border: 1px solid rgba(19, 147, 209, 0.3);"
                />
              );
            }

            return (
              <img
                src={`${import.meta.env.BASE_URL}${imgSrc}`}
                alt={`${name} - Image ${index + 1}`}
                class="gallery-item"
                data-is-website={
                  websiteImgIndexes?.includes(index) ? "true" : "false"
                }
                loading="lazy"
              />
            );
          })}
        </div>
      )
    }

    <button class="back-nav" id="back-button">
      <span class="arrow">←</span>
      <span class="text">Back</span>
    </button>
  </main>

  <script>
    const backButton = document.getElementById("back-button");
    if (backButton) {
      backButton.addEventListener("click", () => {
        // Clear the skip animation flag so animations work when returning
        sessionStorage.removeItem("skipHomeAnimation");
        window.history.back();
      });
    }

    // Adjust project name font size to fit within container
    function adjustTitleSize() {
      const title = document.getElementById("project-name");
      if (!title) return;

      // Use 80vw for mobile, 60vw for desktop
      const viewportWidthPercent = window.innerWidth <= 768 ? 0.8 : 0.6;
      const maxWidth = window.innerWidth * viewportWidthPercent;
      const maxFontSize = 30; // Max 30rem
      const minFontSize = 2; // Min 2rem
      let fontSize = maxFontSize;

      // Start with max size
      title.style.fontSize = `${fontSize}rem`;

      // Decrease font size until it fits
      while (title.scrollWidth > maxWidth && fontSize > minFontSize) {
        fontSize -= 0.1;
        title.style.fontSize = `${fontSize}rem`;
      }

      // If it fits with room to spare, try increasing
      if (title.scrollWidth < maxWidth && fontSize < maxFontSize) {
        while (title.scrollWidth < maxWidth && fontSize < maxFontSize) {
          fontSize += 0.1;
          title.style.fontSize = `${fontSize}rem`;

          // If we went too far, step back
          if (title.scrollWidth > maxWidth) {
            fontSize -= 0.1;
            title.style.fontSize = `${fontSize}rem`;
            break;
          }
        }
      }
    }

    // Run on load and resize
    window.addEventListener("load", adjustTitleSize);
    window.addEventListener("resize", adjustTitleSize);

    // Helper function to check single image aspect ratio
    function checkSingleImageAspect(
      img: HTMLImageElement,
      gallery: HTMLElement
    ) {
      const aspectRatio = img.naturalWidth / img.naturalHeight;
      const isLandscape = aspectRatio > 1.05;

      if (isLandscape) {
        // Landscape: span both columns with cover
        img.classList.add("wide");
        gallery.removeAttribute("data-single-contained");
      } else {
        // Portrait or square: use contain and max-height
        gallery.setAttribute("data-single-contained", "true");
      }
    }

    // Gallery: Smart masonry layout with aspect ratio detection
    function setupGallery() {
      const gallery = document.getElementById("gallery");
      if (!gallery) return;

      const items = Array.from(gallery.querySelectorAll(".gallery-item")) as (
        | HTMLImageElement
        | HTMLIFrameElement
      )[];
      const images = items.filter(
        (item) => item.tagName === "IMG"
      ) as HTMLImageElement[];
      const iframes = items.filter((item) => item.tagName === "IFRAME");
      const totalImages = items.length;

      // Mark all iframes as landscape (wide) immediately
      iframes.forEach((iframe) => {
        iframe.classList.add("wide");
      });

      // If only one image, check if it's a website or portrait/square
      if (totalImages === 1) {
        const item = items[0];

        // If it's an iframe, it's already wide
        if (item.tagName === "IFRAME") {
          gallery.removeAttribute("data-single-contained");
          return;
        }

        const img = item as HTMLImageElement;
        const isWebsite = img.getAttribute("data-is-website") === "true";

        if (isWebsite) {
          // Website images span both columns with normal cover
          img.classList.add("wide");
          gallery.removeAttribute("data-single-contained");
        } else {
          // Non-website single images: check aspect ratio when loaded
          if (img.complete) {
            checkSingleImageAspect(img, gallery);
          } else {
            img.addEventListener("load", () =>
              checkSingleImageAspect(img, gallery)
            );
          }
        }
        return;
      }

      // Wait for all images to load, then analyze
      let loadedCount = 0;
      const aspectRatios: (number | null)[] = [];

      // Add iframes as landscape items with aspect ratio > 1
      items.forEach((item, index) => {
        if (item.tagName === "IFRAME") {
          aspectRatios[index] = 16 / 9; // Landscape aspect ratio
          loadedCount++;
        }
      });

      images.forEach((img: HTMLImageElement) => {
        const itemIndex = items.indexOf(img);
        const checkLoad = () => {
          aspectRatios[itemIndex] = img.naturalWidth / img.naturalHeight;
          loadedCount++;

          if (loadedCount === totalImages) {
            applyLayout(items, aspectRatios);
          }
        };

        if (img.complete) {
          checkLoad();
        } else {
          img.addEventListener("load", checkLoad);
        }
      });
    }

    function applyLayout(
      items: (HTMLImageElement | HTMLIFrameElement)[],
      aspectRatios: (number | null)[]
    ) {
      const gallery = document.getElementById("gallery");
      if (!gallery) return;

      // Classify items: landscape (>1) or portrait/square (<=1)
      const itemData = items.map((item, index: number) => ({
        element: item,
        aspectRatio: aspectRatios[index] || 1,
        type: (aspectRatios[index] || 1) > 1 ? "landscape" : "portrait",
        isIframe: item.tagName === "IFRAME",
      }));

      // Separate landscape and portrait items
      const landscapeItems = itemData.filter(
        (item: any) => item.type === "landscape"
      );
      const portraitItems = itemData.filter(
        (item: any) => item.type === "portrait"
      );

      // Clear gallery and rebuild with new order
      gallery.innerHTML = "";

      // Track portrait items to pair them
      let portraitQueue = [...portraitItems];
      let landscapeIndex = 0;
      let originalIndex = 0;

      while (originalIndex < itemData.length) {
        const originalItem = itemData[originalIndex];

        if (originalItem.type === "landscape") {
          // Add landscape item (spans both columns) - images or iframes
          originalItem.element.classList.add("wide");
          gallery.appendChild(originalItem.element);
          landscapeIndex++;
          originalIndex++;
        } else {
          // Portrait/square item - try to pair with next portrait
          if (portraitQueue.length >= 2) {
            // Add two portrait items side by side
            const first = portraitQueue.shift();
            const second = portraitQueue.shift();

            if (!first || !second) continue;

            first.element.classList.remove("wide");
            second.element.classList.remove("wide");

            // Check if one is portrait and one is square for special styling
            const firstIsPortrait = first.aspectRatio < 0.95;
            const firstIsSquare =
              first.aspectRatio >= 0.95 && first.aspectRatio <= 1.05;
            const secondIsPortrait = second.aspectRatio < 0.95;
            const secondIsSquare =
              second.aspectRatio >= 0.95 && second.aspectRatio <= 1.05;

            if (
              (firstIsPortrait && secondIsSquare) ||
              (firstIsSquare && secondIsPortrait)
            ) {
              // Portrait + Square pair - add special class
              first.element.classList.add("mixed-pair");
              second.element.classList.add("mixed-pair");

              // Only apply mixed pair logic to images, not iframes
              if (
                first.element.tagName === "IMG" &&
                second.element.tagName === "IMG"
              ) {
                let portraitEl: HTMLImageElement, squareEl: HTMLImageElement;
                if (firstIsPortrait) {
                  portraitEl = first.element as HTMLImageElement;
                  squareEl = second.element as HTMLImageElement;
                  first.element.classList.add("portrait-in-pair");
                  second.element.classList.add("square-in-pair");
                } else {
                  portraitEl = second.element as HTMLImageElement;
                  squareEl = first.element as HTMLImageElement;
                  first.element.classList.add("square-in-pair");
                  second.element.classList.add("portrait-in-pair");
                }

                // Dynamically adjust square height to match portrait after render
                setTimeout(
                  () => adjustMixedPairHeights(portraitEl, squareEl),
                  0
                );
              }
            }

            gallery.appendChild(first.element);
            gallery.appendChild(second.element);
          } else if (portraitQueue.length === 1) {
            // Single portrait remaining - span both columns
            const single = portraitQueue.shift();
            if (!single) continue;
            single.element.classList.add("wide");
            gallery.appendChild(single.element);
          }
          originalIndex++;
        }
      }
    }

    // Adjust mixed pair heights to match and fill full grid width
    function adjustMixedPairHeights(
      portraitEl: HTMLImageElement,
      squareEl: HTMLImageElement
    ) {
      // Force both images to render first
      const portraitInitialHeight =
        portraitEl.offsetHeight || portraitEl.naturalHeight;
      const squareInitialHeight =
        squareEl.offsetHeight || squareEl.naturalHeight;

      // Get gallery width and calculate available width for the pair
      const gallery = document.getElementById("gallery");
      const galleryWidth = gallery ? gallery.offsetWidth : 1200;
      const columnGap = 16; // 16px gap
      const availableWidth = galleryWidth - columnGap; // Total width minus gap

      // Get natural dimensions and aspect ratios
      const portraitNaturalWidth = portraitEl.naturalWidth;
      const portraitNaturalHeight = portraitEl.naturalHeight;
      const portraitAspectRatio = portraitNaturalWidth / portraitNaturalHeight;

      const squareNaturalWidth = squareEl.naturalWidth;
      const squareNaturalHeight = squareEl.naturalHeight;
      const squareAspectRatio = squareNaturalWidth / squareNaturalHeight;

      // Use the larger initial height as reference
      const initialHeight = Math.max(
        portraitInitialHeight,
        squareInitialHeight
      );

      // Calculate initial widths based on aspect ratios
      const initialPortraitWidth = initialHeight * portraitAspectRatio;
      const initialSquareWidth = initialHeight * squareAspectRatio;
      const initialTotalWidth = initialPortraitWidth + initialSquareWidth;

      // Calculate scale factor to make total width fill available width
      const scaleFactor = availableWidth / initialTotalWidth;

      // Apply scaled dimensions - BOTH get the same finalHeight
      const finalHeight = initialHeight * scaleFactor;
      const finalPortraitWidth = initialPortraitWidth * scaleFactor;
      const finalSquareWidth = initialSquareWidth * scaleFactor;

      // Set portrait dimensions
      portraitEl.style.height = `${finalHeight}px`;
      portraitEl.style.width = `${finalPortraitWidth}px`;
      portraitEl.style.minHeight = `${finalHeight}px`;
      portraitEl.style.objectFit = "cover";
      portraitEl.style.maxWidth = "none";

      // Set square dimensions - EXACT same height as portrait
      squareEl.style.height = `${finalHeight}px`;
      squareEl.style.width = `${finalSquareWidth}px`;
      squareEl.style.minHeight = `${finalHeight}px`;
      squareEl.style.objectFit = "cover";
      squareEl.style.maxWidth = "none";
    }

    window.addEventListener("load", setupGallery);
  </script>

  <style>
    .project-detail {
      max-width: 1400px;
      margin: 0 auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .back-nav {
      position: fixed;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);

      display: inline-flex;
      align-items: center;
      gap: 0.3rem;

      padding: 0.4rem 1.2rem;
      border-radius: var(--border-radius-md);
      box-shadow: var(--box-shadow);
      border: none;

      font-family: "Owners-XNarrow", sans-serif;
      font-size: 1.3rem;
      font-weight: 800;
      color: var(--color-blue-dark);
      background-color: var(--color-blue-light);
      text-decoration: none;
      text-transform: uppercase;

      cursor: pointer;
      transition: all 0.5s ease;
      z-index: 100;
    }

    .back-nav .line {
      letter-spacing: -0.3em;
    }

    .back-nav {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      transition:
        gap 0.3s ease,
        background-color 0.3s ease,
        color 0.3s ease;
    }

    .back-nav:hover {
      gap: 1rem;
    }

    .arrow {
      font-size: 1.8rem;
    }

    .project-info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1.5rem 1rem;
      margin-bottom: 3rem;
      padding: 1rem 0;
      width: 100%;
      order: 3;
    }

    .info-column {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .info-column:hover .info-title {
      color: var(--color-blue-light);
    }

    .info-column:hover .info-content {
      color: var(--color-blue);
    }

    .info-title {
      font-family: "Owners-XXNarrow", sans-serif;
      font-size: clamp(1.3rem, 2.2vw, 1.8rem);
      color: var(--color-blue);
      font-weight: 600;
      margin: 0;
    }

    .info-content {
      font-family: "Instrument Serif", serif;
      font-size: clamp(0.85rem, 1.1vw, 1rem);
      color: var(--color-blue-light);
      margin-top: -1rem;
      line-height: 1.6;
    }

    .project-name {
      font-family: "Owners-XXNarrow", sans-serif;
      font-size: clamp(3rem, 8vw, 12rem);
      font-weight: 900;
      line-height: 0.9;
      text-transform: uppercase;
      color: var(--color-blue);
      margin: 0 0 2rem 0;
      max-width: 90vw;
      text-align: center;
      white-space: nowrap;
      order: 1;
    }

    .project-description {
      font-family: "Instrument Serif", serif;
      font-size: clamp(1rem, 1.5vw, 1.5rem);
      line-height: 1.5;
      color: var(--color-blue-light);
      max-width: min(85vw, 900px);
      margin: 0 0 2rem 0;
      text-align: center;
      order: 2;
    }

    /* Gallery Styles */
    .gallery {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      width: 100%;
      max-width: min(1200px, 90vw);
      margin: 0 0 4rem 0;
      padding: 0;
      align-items: end; /* Align items to bottom of grid row for better visual balance */
      order: 4;
    }

    /* Single image gallery: show full image (for portrait/square non-website images) */
    .gallery[data-single-contained="true"] {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .gallery[data-single-contained="true"] .gallery-item {
      object-fit: contain;
      max-height: 90vh;
      width: auto;
      max-width: 100%;
      cursor: default;
    }

    .gallery-item {
      width: 100%;
      height: auto;
      object-fit: cover;
      border-radius: var(--border-radius-md, 8px);
      transition: all 0.3s ease;
      cursor: default;
      display: block;
    }

    .gallery-item:hover {
      transform: scale(1.02);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    }

    /* iframe specific styles */
    .gallery-iframe {
      aspect-ratio: 16 / 9;
      border-radius: var(--border-radius-md, 8px);
      background: var(--color-blue-dark);
    }

    .gallery-iframe.wide {
      grid-column: span 2;
    }

    /* Wide images (landscape or single portrait/square) span both columns */
    .gallery-item.wide {
      grid-column: span 1;
    }

    /* Special handling for portrait + square pairs */
    .gallery-item.mixed-pair {
      align-self: end; /* Both align to bottom of grid row */
    }

    .gallery-item.portrait-in-pair,
    .gallery-item.square-in-pair {
      width: 100%;
      height: auto;
      max-height: none;
      min-height: auto;
      max-width: 100%;
    }

    /* Responsive Design */
    @media (min-width: 30rem) {
      .info-title {
        font-size: 1.8rem;
      }

      .info-content {
        font-size: 1.1rem;
      }

      .project-name {
        margin-bottom: 1.5rem;
      }

      .back-nav {
        font-size: 1.5rem;
        padding: 0.4rem 1.5rem;
      }
    }

    @media (min-width: 35rem) {
      .info-title {
        font-size: 2.5rem;
      }

      .info-content {
        font-size: 1.3rem;
      }

      .project-name {
        margin-bottom: 1.5rem;
      }
    }

    @media (min-width: 40rem) {
      .info-title {
        font-size: 2.8rem;
      }

      .info-content {
        font-size: 1.4rem;
      }

      .project-name {
        margin-bottom: 1.2rem;
      }

      .gallery {
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
      }

      .gallery-item.wide {
        grid-column: span 2;
      }

      .gallery-item.portrait-in-pair {
        justify-self: start;
      }

      .gallery-item.square-in-pair {
        width: 100%;
        height: auto;
        max-height: 600px;
        object-fit: cover;
        justify-self: start;
        position: relative;
        z-index: 2;
      }
    }

    @media (min-width: 48rem) {
      .info-title {
        font-size: 3rem;
      }

      .info-content {
        font-size: 1.45rem;
      }

      .project-name {
        margin-bottom: 1rem;
      }

      .project-description {
        margin-bottom: 3rem;
      }
    }

    @media (min-width: 64rem) {
      .project-detail {
        padding: 2rem;
      }

      .project-info-grid {
        grid-template-columns: repeat(4, 1fr);
        gap: 2rem;
        margin-bottom: 4rem;
        padding: 2rem 0;
        order: 1;
      }

      .info-title {
        font-size: clamp(2rem, 3.5vw, 3.5rem);
      }

      .info-content {
        font-size: clamp(1rem, 1.5vw, 1.5rem);
        margin-top: -1.5rem;
      }

      .project-name {
        order: 2;
      }

      .project-description {
        order: 3;
        margin-bottom: 4rem;
      }

      .back-nav {
        font-size: 1.8rem;
        padding: 0.5rem 2rem;
        bottom: 3rem;
        gap: 0.5rem;
      }

      .back-nav:hover {
        gap: 1.5rem;
      }

      .arrow {
        font-size: 2.5rem;
      }
    }
  </style>
</BaseLayout>

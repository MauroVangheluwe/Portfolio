---
import BaseLayout from "./BaseLayout.astro";

interface Props {
  title: string;
  projectName: string;
  projectDescription: any;
  creativeField: string[];
  duration: string;
  year: number;
  client: string;
  software: string[];
}

const {
  title,
  projectName,
  projectDescription: ProjectDescription,
  creativeField,
  duration,
  year,
  client,
  software,
} = Astro.props;
---

<BaseLayout title={title}>
  <main class="project-detail">
    <section class="project-info-grid">
      <div class="info-column">
        <h3 class="info-title">Creative Field</h3>
        <p class="info-content">{creativeField.join(", ")}</p>
      </div>

      <div class="info-column">
        <h3 class="info-title">Duration & Year</h3>
        <p class="info-content">{duration} · {year}</p>
      </div>

      <div class="info-column">
        <h3 class="info-title">Client</h3>
        <p class="info-content">{client}</p>
      </div>

      <div class="info-column">
        <h3 class="info-title">Software</h3>
        <p class="info-content">{software.join(", ")}</p>
      </div>
    </section>

    <h1 class="project-name" id="project-name">{projectName}</h1>
    <div class="project-description">
      <ProjectDescription />
    </div>

    <slot />
  </main>

  <button class="back-nav" id="back-button" slot="fixed">
    <span class="arrow">←</span>
    <span class="text">Back</span>
  </button>

  <!-- Image/Video Overlay Modal -->
  <div id="media-overlay" class="media-overlay" slot="fixed">
    <div class="overlay-content">
      <button
        class="overlay-close"
        id="overlay-close"
        aria-label="Close overlay"
      >
        <svg
          width="32"
          height="32"
          viewBox="0 0 32 32"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M24 8L8 24M8 8L24 24"
            stroke="var(--color-blue-dark)"
            stroke-width="3"
            stroke-linecap="round"></path>
        </svg>
      </button>
      <button
        class="overlay-nav overlay-prev"
        id="overlay-prev"
        aria-label="Previous image"
      >
        <svg
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M15 18L9 12L15 6"
            stroke="var(--color-blue-dark)"
            stroke-width="3"
            stroke-linecap="round"
            stroke-linejoin="round"></path>
        </svg>
      </button>
      <button
        class="overlay-nav overlay-next"
        id="overlay-next"
        aria-label="Next image"
      >
        <svg
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M9 18L15 12L9 6"
            stroke="var(--color-blue-dark)"
            stroke-width="3"
            stroke-linecap="round"
            stroke-linejoin="round"></path>
        </svg>
      </button>
      <div id="overlay-content" class="overlay-media-container">
        <!-- Media will be inserted here -->
      </div>
    </div>
  </div>

  <script>
    const backButton = document.getElementById("back-button");
    if (backButton) {
      backButton.addEventListener("click", () => {
        // Clear the skip animation flag so animations work when returning
        sessionStorage.removeItem("skipHomeAnimation");
        window.history.back();
      });
    }

    // Adjust project name font size to fit within container
    function adjustTitleSize() {
      const title = document.getElementById("project-name");
      if (!title) return;

      // Use 80vw for mobile, 60vw for desktop
      const viewportWidthPercent = window.innerWidth <= 768 ? 0.8 : 0.6;
      const maxWidth = window.innerWidth * viewportWidthPercent;
      const maxFontSize = 30; // Max 30rem
      const minFontSize = 2; // Min 2rem
      let fontSize = maxFontSize;

      // Start with max size
      title.style.fontSize = `${fontSize}rem`;

      // Decrease font size until it fits
      while (title.scrollWidth > maxWidth && fontSize > minFontSize) {
        fontSize -= 0.1;
        title.style.fontSize = `${fontSize}rem`;
      }

      // If it fits with room to spare, try increasing
      if (title.scrollWidth < maxWidth && fontSize < maxFontSize) {
        while (title.scrollWidth < maxWidth && fontSize < maxFontSize) {
          fontSize += 0.1;
          title.style.fontSize = `${fontSize}rem`;

          // If we went too far, step back
          if (title.scrollWidth > maxWidth) {
            fontSize -= 0.1;
            title.style.fontSize = `${fontSize}rem`;
            break;
          }
        }
      }

      // Mark title as ready after calculation
      requestAnimationFrame(() => {
        title.classList.add("ready");
      });
    }

    // Run on load and resize
    window.addEventListener("load", adjustTitleSize);
    window.addEventListener("resize", adjustTitleSize);

    // Helper function to check single image aspect ratio
    function checkSingleImageAspect(
      img: HTMLImageElement,
      gallery: HTMLElement
    ) {
      const aspectRatio = img.naturalWidth / img.naturalHeight;
      const isLandscape = aspectRatio > 1.05;

      if (isLandscape) {
        // Landscape: span both columns with cover
        img.classList.add("wide");
        gallery.removeAttribute("data-single-contained");
      } else {
        // Portrait or square: use contain and max-height
        gallery.setAttribute("data-single-contained", "true");
      }
    }

    // Gallery: Smart masonry layout with aspect ratio detection
    function setupGallery() {
      const gallery = document.getElementById("gallery");
      if (!gallery) return;

      const items = Array.from(gallery.querySelectorAll(".gallery-item")) as (
        | HTMLImageElement
        | HTMLIFrameElement
        | HTMLVideoElement
      )[];
      const images = items.filter(
        (item) => item.tagName === "IMG"
      ) as HTMLImageElement[];
      const videos = items.filter(
        (item) => item.tagName === "VIDEO"
      ) as HTMLVideoElement[];
      const iframes = items.filter((item) => item.tagName === "IFRAME");
      const totalImages = items.length;

      // Mark all iframes as landscape (wide) immediately
      iframes.forEach((iframe) => {
        iframe.classList.add("wide");
      });

      // If only one image/video, check if it's a website or portrait/square
      if (totalImages === 1) {
        const item = items[0];

        // If it's an iframe, it's already wide
        if (item.tagName === "IFRAME") {
          gallery.removeAttribute("data-single-contained");
          gallery.classList.add("ready");
          return;
        }

        // Handle video elements
        if (item.tagName === "VIDEO") {
          const video = item as HTMLVideoElement;
          const checkVideoAspect = () => {
            const aspectRatio = video.videoWidth / video.videoHeight;
            const isLandscape = aspectRatio > 1.05;

            if (isLandscape) {
              video.classList.add("wide");
              gallery.removeAttribute("data-single-contained");
            } else {
              gallery.setAttribute("data-single-contained", "true");
            }
            gallery.classList.add("ready");
          };

          if (video.readyState >= 1) {
            checkVideoAspect();
          } else {
            video.addEventListener("loadedmetadata", checkVideoAspect);
          }
          return;
        }

        const img = item as HTMLImageElement;
        const isWebsite = img.getAttribute("data-is-website") === "true";

        if (isWebsite) {
          // Website images span both columns with normal cover
          img.classList.add("wide");
          gallery.removeAttribute("data-single-contained");
          gallery.classList.add("ready");
        } else {
          // Non-website single images: check aspect ratio when loaded
          const finalCheck = () => {
            checkSingleImageAspect(img, gallery);
            gallery.classList.add("ready");
          };

          if (img.complete) {
            finalCheck();
          } else {
            img.addEventListener("load", finalCheck);
          }
        }
        return;
      }

      // Wait for all images and videos to load, then analyze
      let loadedCount = 0;
      const aspectRatios: (number | null)[] = [];

      // Add iframes as landscape items with aspect ratio > 1
      items.forEach((item, index) => {
        if (item.tagName === "IFRAME") {
          aspectRatios[index] = 16 / 9; // Landscape aspect ratio
          loadedCount++;
        }
      });

      // Handle videos
      videos.forEach((video: HTMLVideoElement) => {
        const itemIndex = items.indexOf(video);
        const checkVideoLoad = () => {
          aspectRatios[itemIndex] = video.videoWidth / video.videoHeight;
          loadedCount++;

          // Try to play the video on mobile after metadata is loaded
          video.play().catch((error) => {
            console.log(
              "Video autoplay prevented, will try on interaction:",
              error
            );
            // Add click handler to play on user interaction
            video.addEventListener(
              "click",
              () => {
                video.play();
              },
              { once: true }
            );
          });

          if (loadedCount === totalImages) {
            applyLayout(items, aspectRatios);
          }
        };

        if (video.readyState >= 1) {
          checkVideoLoad();
        } else {
          video.addEventListener("loadedmetadata", checkVideoLoad);
        }
      });

      // Handle images
      images.forEach((img: HTMLImageElement) => {
        const itemIndex = items.indexOf(img);
        const checkLoad = () => {
          aspectRatios[itemIndex] = img.naturalWidth / img.naturalHeight;
          loadedCount++;

          if (loadedCount === totalImages) {
            applyLayout(items, aspectRatios);
          }
        };

        if (img.complete) {
          checkLoad();
        } else {
          img.addEventListener("load", checkLoad);
        }
      });
    }

    function applyLayout(
      items: (HTMLImageElement | HTMLIFrameElement | HTMLVideoElement)[],
      aspectRatios: (number | null)[]
    ) {
      const gallery = document.getElementById("gallery");
      if (!gallery) return;

      // Mark gallery as ready after layout is applied
      requestAnimationFrame(() => {
        gallery.classList.add("ready");
      });

      // Classify items: landscape (>1) or portrait/square (<=1)
      const itemData = items.map((item, index: number) => ({
        element: item,
        aspectRatio: aspectRatios[index] || 1,
        type: (aspectRatios[index] || 1) > 1 ? "landscape" : "portrait",
        isIframe: item.tagName === "IFRAME",
        isVideo: item.tagName === "VIDEO",
      }));

      // Separate landscape and portrait items
      const landscapeItems = itemData.filter(
        (item: any) => item.type === "landscape"
      );
      const portraitItems = itemData.filter(
        (item: any) => item.type === "portrait"
      );

      // Clear gallery and rebuild with new order
      gallery.innerHTML = "";

      // Track portrait items to pair them
      let portraitQueue = [...portraitItems];
      let landscapeIndex = 0;
      let originalIndex = 0;
      const reorderedElements: (
        | HTMLImageElement
        | HTMLIFrameElement
        | HTMLVideoElement
      )[] = [];

      while (originalIndex < itemData.length) {
        const originalItem = itemData[originalIndex];

        if (originalItem.type === "landscape") {
          // Add landscape item (spans both columns) - images or iframes
          originalItem.element.classList.add("wide");
          gallery.appendChild(originalItem.element);
          reorderedElements.push(originalItem.element);
          landscapeIndex++;
          originalIndex++;
        } else {
          // Portrait/square item - try to pair with next portrait
          if (portraitQueue.length >= 2) {
            // Add two portrait items side by side
            const first = portraitQueue.shift();
            const second = portraitQueue.shift();

            if (!first || !second) continue;

            first.element.classList.remove("wide");
            second.element.classList.remove("wide");

            // Check if one is portrait and one is square for special styling
            const firstIsPortrait = first.aspectRatio < 0.95;
            const firstIsSquare =
              first.aspectRatio >= 0.95 && first.aspectRatio <= 1.05;
            const secondIsPortrait = second.aspectRatio < 0.95;
            const secondIsSquare =
              second.aspectRatio >= 0.95 && second.aspectRatio <= 1.05;

            if (
              (firstIsPortrait && secondIsSquare) ||
              (firstIsSquare && secondIsPortrait)
            ) {
              // Portrait + Square pair - add special class
              first.element.classList.add("mixed-pair");
              second.element.classList.add("mixed-pair");

              // Only apply mixed pair logic to images, not iframes or videos
              if (
                first.element.tagName === "IMG" &&
                second.element.tagName === "IMG"
              ) {
                let portraitEl: HTMLImageElement, squareEl: HTMLImageElement;
                if (firstIsPortrait) {
                  portraitEl = first.element as HTMLImageElement;
                  squareEl = second.element as HTMLImageElement;
                  first.element.classList.add("portrait-in-pair");
                  second.element.classList.add("square-in-pair");
                } else {
                  portraitEl = second.element as HTMLImageElement;
                  squareEl = first.element as HTMLImageElement;
                  first.element.classList.add("square-in-pair");
                  second.element.classList.add("portrait-in-pair");
                }

                // Store the pair for resize handling
                mixedPairs.push({ portrait: portraitEl, square: squareEl });

                // Dynamically adjust square height to match portrait after render
                setTimeout(
                  () => adjustMixedPairHeights(portraitEl, squareEl),
                  0
                );
              }
            }

            gallery.appendChild(first.element);
            gallery.appendChild(second.element);
            reorderedElements.push(first.element);
            reorderedElements.push(second.element);
          } else if (portraitQueue.length === 1) {
            // Single portrait remaining - span both columns
            const single = portraitQueue.shift();
            if (!single) continue;
            single.element.classList.add("wide");
            gallery.appendChild(single.element);
            reorderedElements.push(single.element);
          }
          originalIndex++;
        }
      }

      // Update data-media-index to reflect the new visual order
      // Only update for non-iframe elements (images and videos)
      let visualIndex = 0;
      reorderedElements.forEach((element) => {
        if (element.tagName === "IMG" || element.tagName === "VIDEO") {
          element.setAttribute("data-media-index", visualIndex.toString());
          visualIndex++;
        }
      });
    }

    // Adjust mixed pair heights to match and fill full grid width
    function adjustMixedPairHeights(
      portraitEl: HTMLImageElement,
      squareEl: HTMLImageElement
    ) {
      // Get gallery width and calculate available width for the pair
      const gallery = document.getElementById("gallery");
      if (!gallery) return;

      const galleryWidth = gallery.offsetWidth;
      const viewportWidth = window.innerWidth;

      // Determine if we're in 2-column layout (40rem = 640px)
      const isTwoColumn = viewportWidth >= 640;

      // Use appropriate gap: 16px for desktop (2-column), 12px for mobile (1-column)
      const columnGap = isTwoColumn ? 16 : 12;

      // Calculate available width
      // On mobile (1 column), each image takes full width in its row
      // On desktop (2 columns), images share the row with a gap between them
      const availableWidth = isTwoColumn
        ? galleryWidth - columnGap
        : galleryWidth;

      // Get natural dimensions and aspect ratios
      const portraitNaturalWidth = portraitEl.naturalWidth;
      const portraitNaturalHeight = portraitEl.naturalHeight;
      const portraitAspectRatio = portraitNaturalWidth / portraitNaturalHeight;

      const squareNaturalWidth = squareEl.naturalWidth;
      const squareNaturalHeight = squareEl.naturalHeight;
      const squareAspectRatio = squareNaturalWidth / squareNaturalHeight;

      if (isTwoColumn) {
        // Desktop: Both images side by side, share the available width
        // Calculate heights that will make both images fit the width together

        // Start with an arbitrary height and calculate widths
        let testHeight = 400; // Starting test height
        const testPortraitWidth = testHeight * portraitAspectRatio;
        const testSquareWidth = testHeight * squareAspectRatio;
        const testTotalWidth = testPortraitWidth + testSquareWidth;

        // Scale factor to make them fill the available width
        const scaleFactor = availableWidth / testTotalWidth;

        // Apply scaled dimensions - BOTH get the same finalHeight
        const finalHeight = testHeight * scaleFactor;
        const finalPortraitWidth = testPortraitWidth * scaleFactor;
        const finalSquareWidth = testSquareWidth * scaleFactor;

        // Set portrait dimensions
        portraitEl.style.height = `${finalHeight}px`;
        portraitEl.style.width = `${finalPortraitWidth}px`;
        portraitEl.style.minHeight = `${finalHeight}px`;
        portraitEl.style.objectFit = "cover";
        portraitEl.style.maxWidth = "none";

        // Set square dimensions - EXACT same height as portrait
        squareEl.style.height = `${finalHeight}px`;
        squareEl.style.width = `${finalSquareWidth}px`;
        squareEl.style.minHeight = `${finalHeight}px`;
        squareEl.style.objectFit = "cover";
        squareEl.style.maxWidth = "none";
      } else {
        // Mobile: Images stacked vertically, each takes full width
        // Calculate height based on aspect ratio to fill the width

        const portraitHeight = availableWidth / portraitAspectRatio;
        const squareHeight = availableWidth / squareAspectRatio;

        // Set portrait dimensions to fill width
        portraitEl.style.width = `${availableWidth}px`;
        portraitEl.style.height = `${portraitHeight}px`;
        portraitEl.style.minHeight = `${portraitHeight}px`;
        portraitEl.style.objectFit = "cover";
        portraitEl.style.maxWidth = "100%";

        // Set square dimensions to fill width
        squareEl.style.width = `${availableWidth}px`;
        squareEl.style.height = `${squareHeight}px`;
        squareEl.style.minHeight = `${squareHeight}px`;
        squareEl.style.objectFit = "cover";
        squareEl.style.maxWidth = "100%";
      }
    }

    // Track all mixed pairs for resize handling
    let mixedPairs: Array<{
      portrait: HTMLImageElement;
      square: HTMLImageElement;
    }> = [];

    window.addEventListener("load", () => {
      setupGallery();
      // Initialize media overlay after gallery is set up
      setTimeout(() => {
        initMediaOverlay();
      }, 500);
    });

    // Re-adjust mixed pairs on resize
    let resizeTimeout: ReturnType<typeof setTimeout>;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        mixedPairs.forEach((pair) => {
          adjustMixedPairHeights(pair.portrait, pair.square);
        });
      }, 150);
    });

    // Media Overlay functionality - Initialize after DOM is ready
    function initMediaOverlay() {
      const overlay = document.getElementById("media-overlay");
      const overlayContent = document.getElementById("overlay-content");
      const closeBtn = document.getElementById("overlay-close");
      const prevBtn = document.getElementById("overlay-prev");
      const nextBtn = document.getElementById("overlay-next");
      const gallery = document.getElementById("gallery");

      if (!overlay || !overlayContent || !gallery) {
        console.error("Media overlay elements not found");
        return;
      }

      let currentMediaIndex = 0;
      let mediaItems: (HTMLImageElement | HTMLVideoElement)[] = [];

      // Get all clickable media items (images and videos, excluding iframes)
      function initializeMediaItems() {
        if (!gallery) return;

        const allItems = Array.from(gallery.querySelectorAll(".gallery-item"));
        mediaItems = allItems.filter(
          (item) => item.tagName === "IMG" || item.tagName === "VIDEO"
        ) as (HTMLImageElement | HTMLVideoElement)[];

        console.log("Found media items:", mediaItems.length);
        console.log("Gallery element:", gallery);
        console.log(
          "Gallery pointer-events:",
          window.getComputedStyle(gallery).pointerEvents
        );

        // Test: Add click to document body to see if ANY clicks work
        document.body.addEventListener(
          "click",
          (e) => {
            console.log("Body clicked, target:", e.target);
          },
          true
        );

        // Use event delegation on the gallery container
        gallery.addEventListener(
          "click",
          (e) => {
            console.log("Gallery clicked!");
            const target = e.target as HTMLElement;
            console.log("Click target:", target, "Tag:", target.tagName);

            // Check if clicked element is a media item or inside one
            const mediaElement = target.closest(
              ".gallery-item:not(.gallery-iframe)"
            ) as HTMLElement;
            console.log("Media element found:", mediaElement);

            if (mediaElement && mediaElement.hasAttribute("data-media-index")) {
              e.preventDefault();
              e.stopPropagation();

              const clickedIndex = parseInt(
                mediaElement.getAttribute("data-media-index") || "0",
                10
              );
              console.log("Clicked media item:", clickedIndex);

              // Find the position in our filtered mediaItems array
              const mediaIndex = mediaItems.indexOf(mediaElement as any);
              if (mediaIndex !== -1) {
                openOverlay(mediaIndex);
              }
            }
          },
          true
        );

        // Add cursor pointer style to media items
        mediaItems.forEach((item) => {
          item.style.cursor = "pointer";
        });
      }

      function openOverlay(index: number) {
        if (!overlay) return;

        currentMediaIndex = index;
        showMedia();
        overlay.classList.add("active");
        document.body.style.overflow = "hidden";
      }

      function closeOverlay() {
        if (!overlay || !overlayContent) return;

        overlay.classList.remove("active");
        document.body.style.overflow = "";
        setTimeout(() => {
          if (overlayContent) {
            overlayContent.innerHTML = "";
          }
        }, 300);
      }

      function showMedia() {
        if (!overlayContent) return;

        const mediaItem = mediaItems[currentMediaIndex];
        overlayContent.innerHTML = "";

        if (mediaItem.tagName === "VIDEO") {
          const video = mediaItem as HTMLVideoElement;
          const videoClone = document.createElement("video");
          videoClone.src = video.querySelector("source")?.src || "";
          videoClone.autoplay = true;
          videoClone.loop = true;
          videoClone.muted = true;
          videoClone.playsInline = true;
          videoClone.className = "overlay-media";
          overlayContent.appendChild(videoClone);
        } else {
          const img = mediaItem as HTMLImageElement;
          const imgClone = document.createElement("img");
          imgClone.src = img.src;
          imgClone.srcset = img.srcset || "";
          imgClone.alt = img.alt;
          imgClone.className = "overlay-media";
          overlayContent.appendChild(imgClone);
        }

        if (prevBtn)
          prevBtn.style.display = currentMediaIndex > 0 ? "flex" : "none";
        if (nextBtn)
          nextBtn.style.display =
            currentMediaIndex < mediaItems.length - 1 ? "flex" : "none";
      }

      function showPrevious() {
        if (currentMediaIndex > 0) {
          currentMediaIndex--;
          showMedia();
        }
      }

      function showNext() {
        if (currentMediaIndex < mediaItems.length - 1) {
          currentMediaIndex++;
          showMedia();
        }
      }

      // Event listeners
      closeBtn?.addEventListener("click", closeOverlay);
      prevBtn?.addEventListener("click", showPrevious);
      nextBtn?.addEventListener("click", showNext);

      // Close overlay when clicking outside the image (on the blue background)
      const overlayContentDiv = document.querySelector(
        ".overlay-content"
      ) as HTMLElement;
      overlayContentDiv?.addEventListener("click", (e) => {
        const target = e.target as HTMLElement;
        // Close if clicking on overlay-content or overlay-media-container (blue background areas)
        if (
          target.classList.contains("overlay-content") ||
          target.classList.contains("overlay-media-container")
        ) {
          closeOverlay();
        }
      });

      document.addEventListener("keydown", (e) => {
        if (!overlay.classList.contains("active")) return;
        if (e.key === "Escape") closeOverlay();
        if (e.key === "ArrowLeft") showPrevious();
        if (e.key === "ArrowRight") showNext();
      });

      // Initialize media items
      initializeMediaItems();
    }
  </script>

  <style>
    /* Media Overlay Styles */
    :global(.media-overlay) {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      transition: opacity 0.3s ease;
      padding: 1.5rem;
    }

    :global(.media-overlay.active) {
      display: flex;
      opacity: 1;
      pointer-events: auto;
    }

    :global(.overlay-content) {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      background-color: rgba(179, 215, 231, 0.95);
      border-radius: 12px;
      padding: 4rem;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    :global(.overlay-media-container) {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }

    :global(.overlay-media) {
      max-width: 100%;
      max-height: 75vh;
      width: auto;
      height: auto;
      object-fit: contain;
      border-radius: var(--border-radius-md);
    }

    :global(.overlay-close) {
      position: absolute;
      top: 2rem;
      right: 2rem;
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease;
      z-index: 10001;
    }

    :global(.overlay-close:hover) {
      transform: scale(1.1);
    }

    :global(.overlay-nav) {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: white;
      border: none;
      border-radius: 50%;
      width: 3rem;
      height: 3rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      z-index: 10001;
    }

    :global(.overlay-nav:hover) {
      background: rgba(255, 255, 255, 0.9);
      transform: translateY(-50%) scale(1.1);
    }

    :global(.overlay-prev) {
      left: 2rem;
    }

    :global(.overlay-next) {
      right: 2rem;
    }

    @media (max-width: 48rem) {
      :global(.overlay-close) {
        top: 1rem;
        right: 1rem;
      }

      :global(.overlay-nav) {
        width: 2.5rem;
        height: 2.5rem;
      }

      :global(.overlay-prev) {
        left: 1rem;
      }

      :global(.overlay-next) {
        right: 1rem;
      }

      :global(.overlay-content) {
        max-width: 95vw;
      }
    }

    :global(.back-nav) {
      position: fixed !important;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);

      display: inline-flex;
      align-items: center;
      gap: 0.3rem;

      padding: 0.4rem 1.2rem;
      border-radius: var(--border-radius-md);
      box-shadow: var(--box-shadow);
      border: none;

      font-family: "Owners-XNarrow", sans-serif;
      font-size: 1.3rem;
      font-weight: 800;
      color: var(--color-blue-dark);
      background-color: var(--color-blue-light);
      text-decoration: none;
      text-transform: uppercase;

      cursor: pointer;
      transition: all 0.5s ease;
      z-index: 9999;
    }

    :global(.back-nav .line) {
      letter-spacing: -0.3em;
    }

    :global(.back-nav:hover) {
      gap: 1rem;
    }

    :global(.back-nav .arrow) {
      font-size: 1.8rem;
    }

    .project-detail {
      max-width: 1400px;
      margin: 0 auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .project-info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1.5rem 1rem;
      margin-bottom: 3rem;
      padding: 1rem 0;
      width: 100%;
      order: 3;
    }

    .info-column {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .info-title {
      font-family: "Owners-XXNarrow", sans-serif;
      font-size: clamp(1.3rem, 2.2vw, 1.8rem);
      color: var(--color-blue);
      font-weight: 600;
      margin: 0;
    }

    .info-content {
      font-family: "Instrument Serif", serif;
      font-size: clamp(0.85rem, 1.1vw, 1rem);
      color: var(--color-blue-light);
      margin-top: -1rem;
      line-height: 1.6;
    }

    .project-name {
      font-family: "Owners-XXNarrow", sans-serif;
      font-size: clamp(3rem, 8vw, 12rem);
      font-weight: 900;
      line-height: 0.9;
      text-transform: uppercase;
      color: var(--color-blue);
      margin: 0 0 2rem 0;
      max-width: 90vw;
      text-align: center;
      white-space: nowrap;
      order: 1;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .project-name.ready {
      opacity: 1;
    }

    .project-description {
      font-family: "Instrument Serif", serif;
      font-size: clamp(1rem, 1.5vw, 1.5rem);
      line-height: 1.5;
      color: var(--color-blue-light);
      max-width: min(85vw, 900px);
      margin: 0 0 2rem 0;
      text-align: center;
      order: 2;
    }

    /* Gallery Styles */
    :global(.gallery) {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      width: 100%;
      max-width: min(1200px, 90vw);
      margin: 0 0 4rem 0;
      padding: 0;
      align-items: end;
      order: 4;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    :global(.gallery.ready) {
      opacity: 1;
    }

    :global(.gallery[data-single-contained="true"]) {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    :global(.gallery[data-single-contained="true"] .gallery-item) {
      object-fit: contain;
      max-height: 90vh;
      width: auto;
      max-width: 100%;
      cursor: default;
    }

    :global(.gallery-item) {
      width: 100%;
      height: auto;
      object-fit: cover;
      border-radius: var(--border-radius-md, 8px);
      transition: all 0.3s ease;
      cursor: default;
      display: block;
    }

    :global(.gallery-item:hover) {
      transform: scale(1.02);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    }

    :global(.gallery-iframe) {
      aspect-ratio: 16 / 9;
      border-radius: var(--border-radius-md, 8px);
      background: var(--color-blue-dark);
    }

    :global(.gallery-iframe.wide) {
      grid-column: span 2;
    }

    :global(.gallery-item.wide) {
      grid-column: span 1;
    }

    :global(.gallery-item.mixed-pair) {
      align-self: end;
    }

    :global(.gallery-item.portrait-in-pair),
    :global(.gallery-item.square-in-pair) {
      width: 100%;
      height: auto;
      max-height: none;
      min-height: auto;
      max-width: 100%;
    }

    /* Mobile: Mixed pairs stack vertically, each fills full width */
    @media (max-width: 39.99rem) {
      :global(.gallery-item.portrait-in-pair),
      :global(.gallery-item.square-in-pair) {
        grid-column: span 1;
        width: 100%;
        object-fit: cover;
      }
    }

    /* Responsive Design */
    @media (min-width: 30rem) {
      .info-title {
        font-size: 1.8rem;
      }

      .info-content {
        font-size: 1.1rem;
      }

      .project-name {
        margin-bottom: 1.5rem;
      }

      :global(.back-nav) {
        position: fixed !important;
        font-size: 1.5rem;
        padding: 0.4rem 1.5rem;
      }
    }

    @media (min-width: 35rem) {
      .info-title {
        font-size: 2.5rem;
      }

      .info-content {
        font-size: 1.3rem;
      }

      .project-name {
        margin-bottom: 1.5rem;
      }

      .project-info-grid {
        margin-top: -4rem;
      }
    }

    @media (min-width: 40rem) {
      .info-title {
        font-size: 2.8rem;
      }

      .info-content {
        font-size: 1.4rem;
      }

      .project-name {
        margin-bottom: 1.2rem;
      }

      :global(.gallery) {
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
      }

      :global(.gallery-item.wide) {
        grid-column: span 2;
      }

      :global(.gallery-item.portrait-in-pair) {
        justify-self: start;
      }

      :global(.gallery-item.square-in-pair) {
        width: 100%;
        height: auto;
        max-height: 600px;
        object-fit: cover;
        justify-self: start;
        position: relative;
        z-index: 2;
      }
    }

    @media (min-width: 48rem) {
      .info-title {
        font-size: 3rem;
      }

      .info-content {
        font-size: 1.45rem;
      }

      .project-name {
        margin-bottom: 1rem;
      }

      .project-description {
        margin-bottom: 3rem;
      }
    }

    @media (min-width: 64rem) {
      .project-detail {
        padding: 2.01rem;
      }

      .project-info-grid {
        grid-template-columns: repeat(4, 1fr);
        gap: 0.5rem;
        margin-bottom: 4rem;
        padding: 2rem 0;
        order: 1;
        margin-bottom: -1rem;
        margin-top: 0rem;
      }

      .info-title {
        font-size: clamp(3rem, 3.5vw, 3.5rem);
      }

      .info-content {
        font-size: clamp(1.2rem, 1.5vw, 3rem);
        margin-top: -1.5rem;
      }

      .project-name {
        order: 2;
      }

      .project-description {
        order: 3;
        margin-bottom: 4rem;
      }

      :global(.back-nav) {
        position: fixed !important;
        font-size: 1.8rem;
        padding: 0.5rem 2rem;
        bottom: 3rem;
        gap: 0.5rem;
      }

      :global(.back-nav:hover) {
        gap: 1.5rem;
      }

      :global(.back-nav .arrow) {
        font-size: 2.55rem;
      }
    }

    @media (max-width: 35rem) {
      .project-info-grid {
        margin-top: -4rem;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .info-column {
        margin-top: 0rem;
      }

      .info-title {
        font-size: clamp(3rem, 1.5vw, 4rem);
      }

      .info-content {
        font-size: clamp(1.2rem, 1.5vw, 3rem);
      }
    }
  </style>
</BaseLayout>
